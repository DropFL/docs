---
title: 개요
category: MFQ 스케줄링 시뮬레이터
order: 1
ref: os-pa1-overview
---

*본 문서에서 설명하는 프로젝트는 [이 레포지토리](https://github.com/DropFL/OS_PA1)에서 확인할 수 있습니다.*

## 스펙

이 프로그램은 운영체제의 첫 번째 프로그래밍 과제로 제시된 **MFQ Scheduling Simulation**으로, 다음과 같이 동작하는 MFQ 스케줄러에 의한 프로세스 스케줄링을 구현하는 것이 목표입니다.[^1]

*[MFQ]: [Multi-level Feedback Queue]&#013;독립적인 스케줄링 기법을 갖는 여러 개의 프로세스 큐가 있어,&#013;프로세스가 이 사이를 오가며 실행되는 구조의 스케줄러를 말합니다.

[^1]: 실제로 OS의 커널을 수정하여 스케줄링을 구현하는 것이 아님에 유의하시기 바랍니다.

* 이 MFQ는 4개의 프로세스 큐 $$\{ Q_0, Q_1, Q_2, Q_3 \}$$로 구성됩니다.
* $$Q_i$$에서 실행이 중단된 프로세스 $$P$$가...
  * I/O Burst에 진입하지 않았고 $$Q_{i+1}$$이 존재한다면,  $$P$$는 $$Q_{i+1}$$로 이동합니다.
  * I/O Burst에 진입했고 $$Q_{i-1}$$이 존재한다면, $$P$$는 CPU Burst에 진입할 때 $$Q_{i-1}$$로 이동합니다.
  * 그 외의 경우 $$P$$는 $$Q_i$$에 머무릅니다.
* 각 프로세스 큐의 스케줄링 방식은 다음과 같습니다.

| $$Q_0$$            | $$Q_1$$            | $$Q_2$$          | $$Q_3$$ |
|:------------------:|:------------------:|:----------------:|:-------:|
| RR, time slice = 2 | RR, time slice = 6 | Preemptive SRTN  | FCFS    |

* $$Q_2$$에서 preemption은 I/O burst가 종료되어 $$Q_2$$로 진입하는 프로세스에 의해서만 발생하며, 이 경우 다음 스케줄링 대상은 다른 프로세스 큐의 상태와 무관하게 **진입한 프로세스로 고정**됩니다.
* 우선순위는 $$ Q_0 \gt Q_1 \gt Q_2 \gt Q_3 $$이며, $$Q_2$$ 외에는 **타 프로세스에 의한 preemption이 발생하지 않습니다.**

*[RR]: [Round Robin]&#013;일정한 시간 간격(time slice)을 두고 프로세스를 교체하며 실행하는 방식을 말합니다.
*[SRTN]: [Shortest Remaining Time Next]&#013;완료까지 남은 시간이 가장 짧은 (것으로 추측되는) 프로세스를 우선하여 실행하는 방식을 말합니다.
*[FCFS]: [First Come First Served]&#013;가장 먼저 요청이 들어온 프로세스를 우선하여 실행하는 방식을 말합니다.

예를 들어, $$Q_2$$의 $$P_1$$이 실행되는 상황에서 $$P_2$$가 $$Q_1$$에 진입하더라도 preemption은 발생하지 않지만, $$P_3$$가 $$Q_2$$에 진입하고 그 시점에서 $$P_1$$보다 우선순위가 더 높은 경우 preemption이 발생하며, 이 때 다음에 실행될 프로세스는 $$P_2$$가 아닌 $$P_3$$입니다.

> TODO: add description image

프로그램을 실행 시 출력되어야 하는 항목들은 다음과 같습니다.

* Gantt chart 형태의 각 프로세스의 실행 순서 및 시간 분포
* 각 프로세스 별 TT, WT
* 모든 프로세스들의 평균 TT, WT

*[TT]: [Turnaround Time]; 소요 시간&#013;프로세스에 대한 요청으로부터 완료까지 걸린 시간입니다.
*[WT]: [Waiting Time]; 대기 시간&#013;특정 프로세스가 종료될 때까지 CPU에 의해 수행되지 않은 총 시간입니다.

단, 각 항목에 대한 포맷은 명시되어 있지 않아 출력 형식은 자유롭습니다.

## 입출력 파일 형식

### 입력 (input.txt)

다음은 입력 파일의 예시입니다.

``` text
4
4 1 2 3 10 12 15 16 31
7 1 3 2 14 15 24
2 2 6 1 10
10 2 8 2 14 56 5
```

입력 파일은 시뮬레이션할 프로세스들을 설명하며, 다음과 같이 구성됩니다.

1. 파일 내 첫 번째 숫자는 파일에 등장하는 프로세스 개수를 의미합니다. 이후 입력에서 한 줄은 한 프로세스에 대한 정보를 서술합니다.
2. 각 줄의 첫 번째 숫자는 PID로, 각 프로세스의 고유한 식별자를 의미하는 정수입니다.
   <small>이후 PID = $$n$$인 프로세스를 $$P_n$$라 지칭하고, 편의 상 현재 줄에서 PID = $$k$$라고 가정하겠습니다.</small>
3. 두번째 숫자는 $$P_k$$가 처음에 위치할 프로세스 큐의 번호로, 0 이상 3 이하의 정수입니다.
4. 세번째 숫자는 $$P_k$$가 처음으로 큐에 추가되는 시각(도달 시각)을 나타내는 0 이상의 정수입니다.
5. 네번째 숫자는 $$P_k$$의 CPU & I/O burst 사이클의 횟수[^2]를 나타내는 자연수입니다.
6. 이후 CPU burst와 I/O burst에 해당하는 시간이 번갈아 자연수로 등장합니다. 항상 CPU burst가 먼저 등장하여 CPU burst로 끝납니다. 따라서 5의 숫자가 $$n$$인 경우 이 단계에서 등장하는 숫자는 $$(2n-1)$$개 입니다.

[^2]: 엄밀히는 CPU burst의 등장 횟수를 의미합니다.

### 출력 (output.txt)

다음은 위의 입력에 따른 출력의 일부입니다.

``` text
1 2 3 4 5
|
|
 |
 |
|
|
...
 |
 |
 |
P1: 269 120
P2: 473 105
P3: 83 33
P4: 293 263
P5: 74 34
avg: 238.40 111.00
```

출력 파일은 시뮬레이션 결과 및 분석에 대해 서술하며, 그 구성은 다음과 같습니다.

1. 가장 첫 줄의 숫자들은 입력받은 프로세스들의 PID 목록입니다. $$i$$번째 숫자를 $$a_i$$라 하겠습니다.
2. 두번째 줄부터는 세로로 출력된 Gantt Chart입니다. $$k$$번째 줄은 $$(k-1)$$단위 시간에서의 스케줄링 상태를 나타내며, 공백을 $$n$$개 두고 `|`가 있는 경우 $$P_{a_{n+1}}$$이 실행되었음을 의미합니다. `|`가 없는 줄은 해당 시점에서 CPU가 `IDLE` 상태였음을 뜻합니다.
3. 프로세스의 개수만큼 `Pk: x y`가 출력됩니다. `k`는 PID를 의미하며, `x`, `y`는 각각 $$P_k$$의 TT와 WT입니다.
4. 마지막 줄에는 `avg: X Y`가 출력됩니다. `X`, `Y`는 각각 전체 프로세스의 평균 TT와 WT입니다.

## 프로그램 구동 방법

### 빌드

이 프로젝트는 [CMake](https://cmake.org/)를 이용해 관리됩니다. [CMakeLists.txt](https://github.com/DropFL/OS_PA1/blob/master/CMakeLists.txt) 파일에 3개의 target이 정의되어 있으며, 그 중 `main`이 온전한 프로그램입니다.

별도의 옵션이 명시되진 않아 어렵지 않게 빌드가 가능하나, 만약 실패한다면 `queue_test`나 `proc_test`를 빌드해보시기 바랍니다. 각각은 `main`에 쓰인 모듈의 일부만 포함한 target으로, 각 모듈의 기능을 테스트하기 위해 고안되었습니다. 다음은 각각에 포함된 모듈의 종류입니다.

{:ok: style="color:limegreen"}
{:no: style="color:red"}

| 모듈       | `option`            | `Process`          | `Scheduler`         | `ProcQueue`        | `MFQ`               |
|:----------:|:-------------------:|:------------------:|:-------------------:|:------------------:|:-------------------:|
|`main`      |<span>✔</span>{: ok}|<span>✔</span>{: ok}|<span>✔</span>{: ok}|<span>✔</span>{: ok}|<span>✔</span>{: ok}|
|`queue_test`|<span>✔</span>{: ok}|<span>✔</span>{: ok}|<span>✔</span>{: ok}|<span>✔</span>{: ok}|<span>✘</span>{: no}|
|`proc_test` |<span>✔</span>{: ok}|<span>✔</span>{: ok}|<span>✘</span>{: no}|<span>✘</span>{: no}|<span>✘</span>{: no}|

혹은 CMake가 사용하는 컴파일러나 실행 환경을 확인하시기 바랍니다. 본 프로그램은 [MinGW-w64](https://mingw-w64.org/doku.php)를 이용해 Windows 10 상에서 컴파일 및 테스트가 이루어 졌습니다.

### 실행

다음은 예제 입력을 바탕으로 `main`을 실행한 결과입니다.

``` console
$ main

    Elapsed time: 2
    Proceeded process: 1


    Elapsed time: 2
    Proceeded process: 2

    ...

```

위와 같이 플래그가 선언되지 않은 상태로 실행되면 `input.txt`에서 입력을 받아 `output.txt`에 상술한 결과를 출력하며, 위와 같은 **콘솔 출력**을 내보내게 됩니다. 기본 상태에서 콘솔은 각 단계에서 스케줄링이 일어난 시간과 실행된 프로세스의 PID를 출력합니다.

이 프로그램에는 다음과 같은 커맨드 인자를 사용할 수 있습니다.

| 옵션 종류          | 커맨드 인자         | 설명 |
|:------------------:|:-------------------:|------|
| Verbose 모드       | `-v` or `--verbose` | 더욱 상세한 콘솔 출력을 생성합니다. 현재 프로그램에 적용된 옵션, 입출력 파일 이름, 프로그램 초기화 및 프로세스 스케줄링 과정이 모두 출력됩니다. Output Redirecting을 통해 파일에 출력하여 로그처럼 확인하는 방법을 추천합니다. |
| Silent 모드        | `-s` or `--silent`  | 에러를 제외한 프로그램의 모든 콘솔 출력을 제거합니다. 콘솔 창을 더럽히지 않고 출력 파일을 생성하고 싶을 때 사용하는 플래그입니다. **이 옵션은 Verbose 옵션보다 우선적으로 적용되어,** 두 모드가 동시에 켜져 있으면 콘솔 출력이 사라집니다. |
| **출력 파일 설정** | `-o fileName`       | 출력 파일 이름을 `output.txt`에서 `fileName`으로 변경합니다. |
| **입력 파일 설정** | `fileName`          | 입력 파일 이름을 `input.txt`에서 `fileName`으로 변경합니다. **인자로 들어온 문자열 중 다른 옵션에 해당되지 않는 문자열은 모두 이 옵션으로 해석됩니다.**[^3] |

[^3]: `fileName`은 `-`로 시작할 수 없는데, 플래그를 판별할 때 해당 문자가 사용되기 때문입니다.

플래그의 순서는 크게 상관 없으나, **플래그를 중복으로 선언하면 경고 또는 오류가 발생할 수 있습니다.** 위의 표에서 옵션 종류가 **볼드체**인 경우 중복 선언 시 오류가 발생하여 프로그램이 종료되며, 그렇지 않은 경우 경고는 발생하지만 프로그램은 계속 실행됩니다. 또한, 위에서 정의되지 않은 플래그가 입력된 경우에도 경고가 뜨며 프로그램이 계속 진행됩니다.[^4] 이러한 플래그 관련 메세지는 Silent 모드와 무관하게 항상 출력됩니다.

[^4]: 한 번에 여러 플래그를 선언하는 것은 지원되지 않습니다. `-sv`와 같은 인자를 사용한 경우 정의되지 않은 옵션 경고가 발생합니다.

## 프로젝트 구조

본 프로젝트는 크게 5개의 모듈로 나누어져 있습니다. 자세한 설명은 다음의 문서를 참조하세요.
{% assign modules = site.docs | where: "category", page.category | where_exp : "item", "item != page" | sort: "order" %}

{% for module in modules %}
{{ forloop.index }}. [{{ module.title }}]({{ module.url | absolute_url }}) {% endfor %}

{% include pagenator.html %}
